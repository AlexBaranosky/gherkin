(def defmacro
  (macro (name args & body)
    (list 'def name (cons 'macro (cons args body)))))

(defmacro defn (name args & body)
  (list 'def name (cons 'fn (cons args body))))

(defmacro and (& args)
  (if args
    (if (cdr args)
      (list 'if (car args) (cons 'and (cdr args)))
      (car args))
    t))

(defn inc (n) (+ n 1))

(defn dec (n) (- n 1))

(defn drop (n lst)
  (if (eq? 0 n)
    lst
    (recur (dec n) (cdr lst))))

(defn take (n lst)
  (if (and (> n 0) lst)
    (cons (car lst) (take (dec n) (cdr lst)))))

(defn partition-all (n lst)
  (if lst (cons (take n lst) (partition-all n (drop n lst)))))

(def map
  (fn (f xs)
    (if xs
      (cons (f (car xs)) (map f (cdr xs))))))

(defn reduce (f init xs)
  (if xs
    (recur f (f init (car xs)) (cdr xs))
    init))

(def reverse
  (fn (lst)
    (reduce (fn (xs y) (cons y xs)) nil lst)))

(defmacro let (bindings & body)
  (if bindings
    (reduce
     (fn (inner pair)
       (list
        (cons 'fn (list (list (car pair)) inner))
        (car (cdr pair))))
     (cons 'do body)
     (reverse (partition-all 2 bindings)))
    (cons 'do body)))

(defn or (& args)
  (if args
    (if (nil? (cdr args))
      (car args)
      (let (test-value (gensym))
        (list 'let (list test-value (car args)))))))

(defn count (lst)
  (reduce (fn (x y) (inc x)) 0 lst))

(defn identity (x) x)

(defn every? (pred xs)
  (if xs
    (if (pred (car xs))
      (recur pred (cdr xs)))
    t))

(def some
  (fn (pred xs)
    (if xs
      (if (pred (car xs))
        t
        (recur pred (cdr xs)))
      nil)))

(def or (fn (& xs) (some identity xs)))

(def and (fn (& xs) (every? identity xs)))

(def not (fn (x) (if x nil t)))

(def inverse
  (fn (pred)
    (fn (x) (not (pred x)))))

(def even?
  (fn (n) (eq? 0 (mod n 2))))

(def odd?
  (inverse even?))

(def drop
  (fn (n lst)
    (if (eq? 0 n)
      lst
      (recur (dec n) (cdr lst)))))

(def take
  (fn (n lst)
    (if (> n 0)
      (if lst
        (cons (car lst) (take (dec n) (cdr lst)))))))

(def nth
  (fn (n lst)
    (car (drop n lst))))

(def map
  (fn (f xs)
    (if xs
      (cons (f (car xs)) (map f (cdr xs))))))

(def reverse
  (fn (lst)
    (reduce (fn (xs y) (cons y xs)) nil lst)))

(def concat
  (fn (lst & more)
    (if lst
      (cons (car lst) (apply concat (cons (cdr lst) more)))
      (if more
        (apply concat more)))))

(def partial
  (fn (f & args)
    (fn (& more)
      (apply f (concat args more)))))

(def juxt
  (fn (& fns)
    (fn (arg)
      (map (fn (f) (f arg)) fns))))

(def repeat
  (fn (n x)
    (if (> n 0) (cons x (repeat (dec n) x)))))

(def interleave
  (fn (& lst)
    (if (every? identity lst)
      (concat (map car lst) (apply interleave (map cdr lst))))))

(def interpose
  (fn (sep lst)
    (drop 1 (interleave (repeat (count lst) sep) lst))))

(def join
  (fn (sep lst)
    (apply str (interpose sep lst))))

(def filter
  (fn (pred lst)
    (if lst
      (if (pred (car lst))
        (cons (car lst) (filter pred (cdr lst)))
        (recur pred (cdr lst))))))

(def remove
  (fn (pred lst)
    (filter (inverse pred) lst)))
